class Solution(object):
    def visiblePoints(self, p, a, l):
        ma=0
        #正好在站位上的点可能有好几个，这几个点肯定保底能看到，因为没法计算准确的方位角，要提前删掉，计算结果的时候再加上去
        flag=0
        for x in p:
            if l==x:
                p.remove(l)
                flag+=1
        import math
        #计算出的方位角不是首尾相接的，因此要复制一次角度数组，然后加上360再与原来拼起来，这样就解决了视野连续的问题
        w=sorted([math.atan2(x[1]-l[1], x[0]-l[0])/math.pi*180 for x in p])
        # 这里排序的结果其实就是按照圆周顺序排序
        w1=[x+360 for x in w]
        w=w+w1
        """
        // 这里的本质是将数组扩为了两倍，因为园是首尾相接的，保证窗口的全覆盖
        // 我们开始的地方是有可能成为某一种情况的中间位置的
        // 这里需要处理的问题是：我们滑动的时候，相当于在圆周上转动，当我们转过一周的时候，之前遍历的点时发生变化的
        // 虽然之前计算的我们在图上看着是连续的，但是用数学逻辑上讲，角为了保持连续，已经加了2π，所以这里扩充的数据变成了大于360度的角
        """
        n=len(w)
        left,right=0,0
        #建立了方位角数组然后利用双指针记录索引的最大差值
        while(right<n):
            if(w[right]-w[left]<=a):#正好在视野边线上点都同时算作在视野内，注意计算的精度，注意等于号是否该取
                right+=1
                ma=max(ma,right-left)
            else:
                left+=1
        return flag+ma