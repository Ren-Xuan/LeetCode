from typing import List


class Solution:
    def minOperations1(self, nums: List[int]) -> int:
        """
        本题给定了两种操作：

        让序列中某个数加 1；

        让序列中所有数全体乘以 2。

        询问你需要操作多少次，才能得到目标数组。

        我们可以采用逆向思维，从目标数组转化为初始数组，支持两种操作：

        让序列中某个数减 1；

        让序列中所有数全体除以 2（要求序列中所有数均为偶数）。

        询问你最少需要多少步才能让给定的数组中的全部元素变为 0。

        我们贪心地考虑每一个数，显然我们应当尽可能多的执行第二种操作。
        因此我们只需要每次将序列中所有的奇数减 1，使其变为偶数，
        然后让整个偶数序列全体除以 2，直到所有数变为 0 为止。

        对于任意一个数，我们从二进制的角度考虑：

        如果它是奇数，那么它将被执行第一种操作。它的二进制表示中的末尾的 1 将会变成 0；

        如果它是偶数，那么它将被执行第二种操作。它的二进制表示将会整体右移一位。

        我们注意到对于任意一个数，它被执行第一种操作的次数等于它的二进制表示中的 1 的数量。
        我们只需要统计序列中所有数的二进制表示中 1 的数量之和，
        即可统计出第一种操作的数量。
        而第二种操作是全体数共同执行的，它的执行次数取决于序列中所有数的二进制表示的最高位数。
        我们只需要记录序列中最大值的二进制表示的位数，即可算出第二种操作的数量。


        """
        maxn = max(nums)
        ret = 0
        for num in nums:
            while num > 0:
                if num & 1:
                    ret += 1
                num >>= 1
        if maxn > 0:
            while maxn > 0:
                ret += 1
                maxn >>= 1
            ret -= 1
        
        return ret

    def minOperations(self, nums: List[int]) -> int:
        c = 0
        for i in nums:
            c += bin(i).count("1")
        c += len(bin(max(nums))) - 3
        return c